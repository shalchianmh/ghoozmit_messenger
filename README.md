# ghoozmit_messenger
این پروژه با رویکردی سخاوتمندانه تحت پوشش لایسنس آپاچی دو قرار میگیرد تا همه رهپویان علم و سعادت بتوانند از تکنولوژی استفاده شده سیراب گردند

<div dir="rtl">

## خلاصه تغییرات پروژه در مرحله‌ی `Step-01-without-solid`

| فایل / کلاس                       | نوع تغییر             | شرح مختصر                           |
|----------------------------------|-----------------------|-----------------------------------------------------------------|
| Main.java                        | اضافه کردن گزینه منو  | یه خط به منوی انتخاب‌ها اضافه کردیم که گزینه ارسال پیام تلگرام (`TelegramMessage`) را هم داشته باشه |
| Main.java                        | اضافه کردن حالت جدید  | توی بخش `switch`، حالت جدیدی برای ساخت پیام تلگرام (`TelegramMessage`) گذاشتیم که اطلاعاتش را می‌گیره |
| Main.java                        | اضافه کردن ارسال پیام | وقتی پیام از نوع تلگرام (`TelegramMessage`) باشه، اون را با سرویس مخصوص تلگرام (`TelegramMessageService`) ارسال کنیم |
| TelegramMessage.java             | ایجاد کلاس جدید       | یک کلاس جدید ساختیم به اسم `TelegramMessage` که اطلاعات کاربر مبدا و مقصد را نگه می‌داره |
| TelegramMessageService.java      | ایجاد کلاس جدید       | کلاس جدیدی ساختیم به اسم `TelegramMessageService` که کار ارسال پیام تلگرام را انجام می‌ده |
| TelegramMessageService.java      | نوشتن تابع ارسال     | تابع `sendTelegramMessage` نوشتیم که اول نام‌های کاربری را چک می‌کنه بعد پیام را چاپ می‌کنه |
| TelegramMessageService.java      | نوشتن تابع اعتبارسنجی | تابع کمکی `validateTelegramUsername` نوشتیم که نام‌های کاربری تلگرام را اعتبارسنجی کنه |
| MessageService.java (interface)  | اضافه کردن متد       | توی اینترفیس `MessageService`، متد `sendTelegramMessage` را اعلام کردیم |
| SmsMessageService.java           | اضافه کردن متد       | متد `sendTelegramMessage` را به کلاس `SmsMessageService` اضافه کردیم، ولی پیاده‌سازی نکردیم |
| EmailMessageService.java         | اضافه کردن متد       | متد `sendTelegramMessage` را به کلاس `EmailMessageService` اضافه کردیم، ولی پیاده‌سازی نکردیم |


تغییرات کلاس Main را 3 تا حساب کردیم چون که جاهای مختلفی بودند.<br>
اضافه کردن مدل `TelegramMessage` را هم یک تغییر در نظر گرفتیم، چون توابع setter/getter را به عنوان تغییر جداگانه حساب نکردیم.
<br>
ولی اضافه کردن کلاس `TelegramMessageService` را از دو تابع کنترلی داخلش جدا حساب کردیم و شد 3 تغییر.
بنابراین با این منطق در کل <b>10 تغییر</b> معنادار در پروژه به وجود آمد.

## بررسی اصول SOLID در پروژه

| اصل | وضعیت | توضیح |
|------|--------|--------|
| اصل 1 - Single Responsibility | موارد تحقق | هر سرویس (مثل `EmailMessageService`) فقط منطق ارسال پیام مربوط به خودش را پیاده‌سازی کرده است و شامل اعتبارسنجی و چاپ پیام است. |
| اصل 1 - Single Responsibility | موارد نقص | پیاده‌سازی متدهای خالی در کلاس‌هایی که مسئولیتی در قبال آن نوع پیام ندارند (مثلاً `sendSmsMessage` در `TelegramMessageService`) نشان‌دهنده نقض اصل تک‌وظیفه‌ای است. |
| اصل 2 - Open/Closed | موارد تحقق | در کلاس `Main` از اینترفیس `MessageService` استفاده شده و پیاده‌سازی‌ها به صورت مستقل افزوده می‌شوند، بدون نیاز به تغییر منطق کد اصلی. |
| اصل 2 - Open/Closed | موارد نقص | اضافه کردن نوع پیام جدید مستلزم افزودن متد جدید به اینترفیس و تغییر در تمام کلاس‌های پیاده‌ساز (حتی اگر متد جدید را خالی بگذارند) است. |
| اصل 3 - Liskov Substitution | موارد تحقق | همه کلاس‌های پیاده‌ساز `MessageService` را می‌توان بدون ایجاد خطا جایگزین یکدیگر کرد و در کد از آن‌ها استفاده نمود. |
| اصل 3 - Liskov Substitution | موارد نقص | جایگزینی یک سرویس با سرویسی دیگر که متد مربوطه را خالی دارد (مثلاً فراخوانی `sendEmailMessage` روی `SmsMessageService`) ممکن است رفتار ناپایدار ایجاد کند. |
| اصل 4 - Interface Segregation | موارد تحقق | استفاده از Interface واحد، قرارداد کلی بین سرویس‌ها و مصرف‌کننده (کلاس Main) را مشخص می‌کند. |
| اصل 4 - Interface Segregation | موارد نقص | `MessageService` شامل متدهایی است که همه پیاده‌سازی‌ها به آن نیازی ندارند، در نتیجه کلاس‌ها مجبور به پیاده‌سازی متدهای بی‌استفاده شده‌اند. |
| اصل 5 - Dependency Inversion | موارد تحقق | کلاس `Main` به اینترفیس `MessageService` وابسته است و جزئیات پیاده‌سازی‌ها جدا نگه داشته شده‌اند. |
| اصل 5 - Dependency Inversion | موارد نقص | استفاده از `instanceof` برای تعیین نوع پیام و ساخت نمونه سرویس مناسب، وابستگی مستقیم به کلاس‌های concrete ایجاد کرده است. |


## راه حل پیشنهادی برای پیاده سازی اصول SOLID در پروژه

|اصل مربوطه(از اصول SOLID) | علت نقض | راه حل پیشنهادی|
|-----------------|------------|----------------------|
|اصل 1 - Single Responsibility| پیاده سازی متود های خالی در کلاس هایی که مسئول انجام آن کار نیستند. این کار باعث می‌شود که این کلاس به چیزی وابسته باشد که مسئول انجام آن نیست و اگر در آینده تغییری در آن متود بدهیم باید بدون دلیل این کلاس را هم تغییر بدهیم.| باید اینترفیسی که این کلاس ها آن را پیاده سازی می‌کنند را بشکنیم و چند اینترفیس کوچکتر بسازیم که هر کدام مسئولیتی مشخص داشته باشند.|
|اصل 2 - Open/Closed| با وجود یک کلاس اینترفیس و با افزودن یک متود جدید مجبور هستیم تمام کلاس های سرویس را که این اینتر فیس را پیاده سازی کرده اند، تغییر دهیم و متود را که بعضا اصلا به آن احتیاج هم ندارند به این کلاس ها اضافه کنیم.|باید طبق کاری که در مشکل قبلی کردیم اینترفیس را بشکنیم و برای هر مسئولیت یک اینترفیس جدا بنویسیم.|
|اصل 3 - Liskov Substitution|مشکلی که وجود دارد این است که اگر هرکدام از کلاس های پیاده سازی شده را به جای اینترفیس اصلی استفاده کنیم ممکن است با رفتاری غیرمنتظره مواجه شویم زیرا این کلاس ها هر کدام بنا به مسئولیتی که دارند تعدادی از متود ها را خالی گذاشته اند.|باید چند اینترفیس داشته باشیم و اینترفیس کلی را بشکنیم. با این کار اگر هر کلاس پیاده سازی را با انترفیسش جایگزین کنیم دقیقا همان رفتار ها را می‌بینیم.|
|اصل 4 - Interface Segregation| با وجود اینترفیس MessageService همه کلاس هایی که این اینترفیس را پیاده سازی می‌کنند مجبور هستند تا تمام متود ها را پیاده سازی کنند. از این رو متود های خالی یه وجود می‌آید.|تفکیک اینترفیس ها باعث می‌شود که هر کلاس متود های مربوط به کار خود را داشته باشد.|
|اصل 5 - Dependency Inversion|
</div>
